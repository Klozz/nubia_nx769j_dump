#!/system/bin/sh

export PATH=/vendor/xbin:$PATH
platform=`getprop ro.board.platform`
cell=`getprop ro.vendor.feature.for_zte_cell`
system_id=`getprop ro.cell.name`
SDM845_PLATFORM="sdm845"
SDM450_PLATFORM="msm8953"

CACHEDIR=/cache
DATADIR=/data
SYSDIR=/data/local
LOGDIR=$SYSDIR/vendor_logs
LOGS_DIR=vendor_logs

if [ "$platform" == "$SDM845_PLATFORM" -o "$platform" == "$SDM450_PLATFORM" ];then
    DATADIR=/cache
    SYSDIR=/cache
    LOGDIR=$SYSDIR/logs
    LOGS_DIR=logs
fi

INTERVAL_MAIN=30

function debug()
{
    echo $1
}

function bak_if()
{
    debug "bak_if2 begin"
    local bakfile=$1
    local file=${bakfile##*/}
    local dir=${bakfile%/*}
    local size=$2

    debug "bakfile:$bakfile file:$file dir:$dir size:$size"
    if [ ! -f $bakfile ] ; then
        debug "bakfile:$bakfile donot exist"
        return
    fi

    l=`du -s   $bakfile | sed 's/[\t ][\t ]*/\n/g' | sed -n '1p'`
    if [ "$l" -gt "$2" ] ;then
        debug "rm $bakfile.0.tar.gz"
        rm $bakfile.0.tar.gz
        pwd
        debug "cd $dir"
        cd $dir
        debug "$file -> $file.0.tar.gz"
        tar zcf $file.0.tar.gz $file
        debug "rm $file"
        rm $file
        cd -
        pwd
    fi
    debug "bak_if2 end"
}

function get_acct_info()
{
    debug "get_acct_info begin"
    if ["$system_id" == ""] ; then
        debug "skip get_pm_log in home and work"
        return
    fi
    date >> $LOGDIR/logcat/pmlog2/acct.txt
    if [ -e /system/bin/zbugreport ]; then
        zbugreport acct >> $LOGDIR/logcat/pmlog2/acct.txt
    return
    fi
    for i in /acct/*;
    do if [ -d $i ];
        then if [ -e $i/cpuacct.usage ];
              then echo $i : `cat $i/cpuacct.usage`;
        fi;
    fi;
    done >> $LOGDIR/logcat/pmlog2/acct.txt;
    echo "========================================" >> $LOGDIR/logcat/pmlog2/acct.txt
    debug "get_acct_info end"
}

function get_pm_log()
{
    debug "get_pm_log2 begin"
    echo "get_pm_log"
    get_acct_info
    bak_if  $LOGDIR/logcat/pmlog2/acct.txt 8192
    debug "get_pm_log2 end"
}


function packages_info_boot()
{
    debug "packages_info_boot begin"
    #pm list packages > $LOGDIR/logcat/installedapp.txt
    cat /data/system/packages.xml > $LOGDIR/logcat/packages-boot.xml
    cat /data/system/device_policies.xml > $LOGDIR/logcat/device_policies-boot.xml
    cat /data/system/users/0/package-restrictions.xml > $LOGDIR/logcat/package-restrictions-boot.xml
    cat /data/misc_de/0/apexdata/com.android.permission/runtime-permissions.xml > $LOGDIR/logcat/runtime-permissions-boot.xml
    cat /data/misc_de/999/apexdata/com.android.permission/runtime-permissions.xml > $LOGDIR/logcat/runtime-permissions-boot-999.xml
    cat /data/system/users/0/settings_secure.xml  > $LOGDIR/logcat/settings_secure-boot.xml
    cat /data/system/users/0/settings_system.xml > $LOGDIR/logcat/settings_system-boot.xml
    cat /data/system/users/0/settings_global.xml >  $LOGDIR/logcat/settings_global-boot.xml
    cat /data/system/notification_policy.xml >  $LOGDIR/logcat/notification_policy-boot.xml
    cat /data/system/appops.xml >  $LOGDIR/logcat/appops.xml
    chmod 755 $LOGDIR/logcat/*.xml
    debug "packages_info_boot end"
}

function packages_info()
{
    debug "packages_info begin"
    echo "packagesinfo every 60"
    #pm list packages > $LOGDIR/logcat/installedapp.txt
    cat /data/system/packages.xml > $LOGDIR/logcat/packages.xml
    cat /data/system/device_policies.xml > $LOGDIR/logcat/device_policies-boot.xml
    cat /data/system/users/0/package-restrictions.xml > $LOGDIR/logcat/package-restrictions.xml
    cat /data/misc_de/0/apexdata/com.android.permission/runtime-permissions.xml > $LOGDIR/logcat/runtime-permissions.xml
    cat /data/misc_de/999/apexdata/com.android.permission/runtime-permissions.xml > $LOGDIR/logcat/runtime-permissions-999.xml
    cat /data/system/users/0/settings_secure.xml  > $LOGDIR/logcat/settings_secure.xml
    cat /data/system/users/0/settings_system.xml > $LOGDIR/logcat/settings_system.xml
    cat /data/system/users/0/settings_global.xml >  $LOGDIR/logcat/settings_global.xml
    cat /data/system/notification_policy.xml >  $LOGDIR/logcat/notification_policy.xml
    cat /data/system/appops.xml >  $LOGDIR/logcat/appops.xml
    chmod 755 $LOGDIR/logcat/*.xml
    debug "packages_info end"
}

function backup_traces()
{
    debug "backup_traces begin"
    #cp -f /data/anr/traces* $LOGDIR/logcat/
    #rm -f /data/anr/traces*

    local tf
    local tt=`date +%G%m%d_%H%M%S`
    if [ ! -d /data/anr/ ]
    then
        return
    fi
    local curdir=`pwd`
    cd /data/anr/
    for  tf in  `ls traces*`
    do
        local file=${tf##*/}
        #debug "cp -f ${tf} $LOGDIR/logcat/${tt}_${file}"
        #cp -f ${tf} $LOGDIR/logcat/${tt}_${file}
        debug "tar zcf $LOGDIR/logcat/${tt}_${file}.tar.gz ${tf}"
        tar zcf $LOGDIR/logcat/${tt}_${file}.tar.gz ${tf}
    done
    rm -f /data/anr/traces*
    for  tf in  `ls anr_*`
    do
        local file=${tf##*/}
        debug "tar zcf $LOGDIR/logcat/${tt}_${file}.tar.gz ${tf}"
        tar zcf $LOGDIR/logcat/${file}.tar.gz ${tf}
    done
    rm -f /data/anr/anr_*
    for  tf in  `ls BinderTraces*`
    do
        local file=${tf##*/}
        debug "tar zcf $LOGDIR/logcat/${tt}_${file}.tar.gz ${tf}"
        tar zcf $LOGDIR/logcat/${file}.tar.gz ${tf}
    done
    rm -f /data/anr/BinderTraces*
    cd $curdir
    debug "backup_traces end"
}

function mainloop()
{
    debug "mainloop begin"
    local interval=0
    local e
    local next

    for e in ${crontab[@]}
    do
        eval next=\${${e}[0]}
        eval interval=\${${e}[1]}
        debug "----->cure:$e next:$next interval:$interval system_uptime:$sys_uptime"
        if [ "$sys_uptime" -ge "$next" ] ;then
            interval=`expr $interval + $sys_uptime`
            eval ${e}[0]=\$interval
            eval next=\${${e}[0]}
            debug "next:$next $interval $sys_uptime"
            eval local len=\${#${e}[@]}
            local funi=2
            while [ $funi -lt $len ]
            do
                eval \${${e}[$funi]}
                eval debug \${${e}[$funi]}
                funi=`expr $funi + 1`
            done
        fi
    done
    debug "mainloop end"
}

function call_at()
{
    debug "call_at begin"
    local which
    local when
    local fun
    for which in ${crontab_at[*]}
    do
        eval when=\${${which}[0]}
        eval fun=\${${which}[1]}
        if [ "$when" -ne "0" ] ; then
            debug "$fun will call at $when"
        fi

        if [ "$when" -ne "0" -a "$sys_uptime" -ge "$when" ] ; then
            $fun
            eval ${which}[0]=0
        fi
    done
    debug "call_at end"
}



function onboot()
{
    debug "onboot begin"
    if [ "$isbootcomplete" -eq "1" ] ;then
        return
    fi
    chmod 744 $LOGDIR/logcat/dropbox/*
    local bootanim_service=`getprop init.svc.bootanim`
    if [ "$bootanim_service" != "stopped" ] ;then
        debug "bootanim service $bootanim_service"
        return
    fi
    isbootcomplete=1
    for func in ${onbootcomplete[@]}
    do
        debug "call $func when bootcomplete"
        $func
    done
    debug "onboot end"
}

mkdir $LOGDIR/logcat/pmlog2
chmod 755 /data/system/dropbox
mkdir $LOGDIR/logcat/dropbox
chown system.root $LOGDIR/logcat/dropbox
chmod 755 $LOGDIR/logcat/dropbox
every30s=(0 29 backup_traces)
every60s=(0 59 packages_info get_pm_log)
every600s=(0 599 debug)
every30m=(0 1799 debug)


if [ "$cell" == "true" ]; then
    debug "cell true"
    crontab=(every30s every60s)
else
    debug "cell false"
    crontab=(every30s every60s every600s every30m)
fi

onbootcomplete=(packages_info_boot)
isbootcomplete=0
sys_uptime=$INTERVAL_MAIN
while true
do
    onboot
    call_at

    mainloop
    sec=$INTERVAL_MAIN
    debug "need to sleep $sec sys_uptime=$sys_uptime INTERVAL_MAIN=$INTERVAL_MAIN"
    sleep $sec
    sys_uptime=`expr $sys_uptime + $INTERVAL_MAIN`
done
